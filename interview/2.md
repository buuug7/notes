# 最近整理的 JavaScript 相关面试题


## js 中， 0.1 + 0.2 === 0.3 是否为 true ? 在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？

0.1+0.2 === 0.30000000000000004(17 位小数)，返回为 false，所以不相等。

在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？可以使用 toFixed()对计算结果进行精度缩小来处理。

```javascript
const a = 0.1;
const b = 0.2;
const c = 0.3;

const sum = (a + b).toFixed(1);
console.log(sum === c.toString()); // true
```

## 如何解决不同浏览器的样式兼容性问题？

- 在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。
- 使用已经处理好此类问题的库，比如 Bootstrap。
- 使用 autoprefixer 自动生成 CSS 属性前缀。
- 使用 Reset CSS 或 Normalize.css。

## 如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？

- 优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。
- 渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。
- 利用 caniuse.com 检查特性支持。
- 使用 autoprefixer 自动生成 CSS 属性前缀。
- 使用 Modernizr 进行特性检测。

## 响应式设计与自适应设计有何不同？

响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。

响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。

自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。


## 请简述 JavaScript 中的 this。

JS 中的 this 是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了 this 的值。this 取值符合以下规则：

- 在调用函数时使用 new 关键字，函数内的 this 是一个全新的对象。
- 如果 apply、call 或 bind 方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。
- 当函数作为对象里的方法被调用时，函数内的 this 是调用该函数的对象。比如当 obj.method()被调用时，函数内的 this 将绑定到 obj 对象。
- 如果调用函数不符合上述规则，那么 this 的值指向全局对象（global object）。浏览器环境下 this 的值指向 window 对象，但是在严格模式下('use strict')，this 的值为 undefined。
- 如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定 this 的值。
- 如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，this 被设置为它被创建时的上下文。

## 请解释原型继承（prototypal inheritance）的工作原理。

这是一个非常常见的 JavaScript 问题。所有 JS 对象都有一个`__proto__`属性，指向它的原型对象。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。这种行为是在模拟经典的继承。

## null、undefined 和未声明变量之间有什么区别？如何检查判断这些状态值？

当没有提前使用 var、let 或 const 声明变量，就为一个变量赋值时，成为全局作用域下定义的变量。在严格模式下，给未声明的变量赋值，会抛出 ReferenceError 错误。

当一个变量已经声明，但没有赋值时，该变量的值是 undefined。如果一个函数的执行结果被赋值给一个变量，但是这个函数却没有返回任何值，那么该变量的值是 undefined。可以使用 `typeof` 或者 `===` 去检测一个值是否是 undefined。

null 只能被显式赋值给变量。它表示空值，与被显式赋值 undefined 的意义不同。要检查判断 null 值，需要使用严格相等运算符。

## 使用 Ajax 的优缺点分别是什么？

优点：

- 交互性更好。来自服务器的新内容可以动态更改，无需重新加载整个页面。
- 减少与服务器的连接，因为脚本和样式只需要被请求一次。
- 状态可以维护在一个页面上。JavaScript 变量和 DOM 状态将得到保持，因为主容器页面未被重新加载。
- 基本上包括大部分 SPA 的优点。

缺点：

- 动态网页很难收藏。
- 如果 JavaScript 已在浏览器中被禁用，则不起作用。
- 有些网络爬虫不执行 JavaScript，也不会看到 JavaScript 加载的内容。
- 基本上包括大部分 SPA 的缺点

## javascript 设置 cookie

```javascript
// 设置cookie
const now = new Date();
now.setTime(now.getTime() + 24 * 60 * 60 * 1000);
document.cookie = `key=value;expires=${now.toUTCString()};path=/;domain=localhost`;

// 读取cookie
const cookies = document.cooke;
```

## 什么是"use strict";？使用它有什么优缺点？

`use strict`是用于对整个脚本或单个函数启用严格模式的语句。严格模式是可选择的一个限制 JavaScript 的变体一种方式 。

优点：

- 无法再意外创建全局变量。
- 会使引起静默失败（silently fail，即：不报错也没有任何效果）的赋值操抛出异常。
- 试图删除不可删除的属性时会抛出异常（之前这种操作不会产生任何效果）。
- 要求函数的参数名唯一。
- 全局作用域下，this 的值为 undefined。
- 捕获了一些常见的编码错误，并抛出异常。
- 禁用令人困惑或欠佳的功能。

缺点：

- 无法访问 function.caller 和 function.arguments。
- 以不同严格模式编写的脚本合并后可能导致问题。

总的来说，我认为利大于弊，我从来不使用严格模式禁用的功能，因此我推荐使用严格模式。


## 原型链继承

通过申明一个构造函数，然后在该构造函数的原型上添加属性和方法，然后子类调用父类构造函数来达到继承的目的。

```javascript
function Animal() {
  this.color = "red";
}
Animal.prototype.say = function () {
  return "I am a animal";
};

function Dog() {}
Dog.prototype = new Animal();

const dog1 = new Dog();
dog1.say(); // I am a animal
```

存在的问题：

- 子类在实例化的时候不能给父类构造函数传参
- 原型中包含的引用类型属性将被所有实例共享

## 借用构造函数实现继承

```javascript
function Animal(name) {
  this.name = name;
  this.getName = function () {
    return this.name;
  };
}

function Dog(name) {
  Animal.call(this, name);
}

Dog.prototype = new Animal();
```

借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。

## 组合继承

组合继承结合了原型链和借用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过借用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。

```javascript
function Animal(name) {
  this.name = name;
  this.colors = ["red", "green"];
}

Animal.prototype.getName = function () {
  return this.name;
};

function Dog(name, age) {
  Animal.call(this, name);
  this.age = age;
}

Dog.prototype = new Animal();
Dog.prototype.constructor = Dog;

const dog1 = new Dog("dog1", 1);
dog1.colors.push("blue");
const dog2 = new Dog("dog2", 2);
dog2.colors.push("black");
console.log(dog1); // Dog { name: 'dog1', colors: [ 'red', 'green', 'blue' ], age: 1 }
console.log(dog2); // Dog { name: 'dog2', colors: [ 'red', 'green', 'black' ], age: 2 }
```

## class 实现继承

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  getName() {
    return this.name;
  }
}
class Dog extends Animal {
  constructor(name, age) {
    super(name);
    this.age = age;
  }
}
```

## 数组扁平化

数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层。

```javascript
[1, [2, [3]]].flat(2); // [1, 2, 3]
```

```javascript
// 实现flat
function flat(arr) {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flat(arr));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
```

## 对象 copy

// 普通实现，只考虑普通对象属性，不考虑内置对象和函数。

```javascript
function deepCopy(obj) {
  if (typeof obj !== "object") {
    return;
  }

  let newObj = obj instanceof Array ? [] : {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] =
        typeof obj[key] === "object" ? deepCopy(obj[key]) : obj[key];
    }
  }

  return newObj;
}

const p1 = { name: "tom", age: 22 };
const p2 = deepCopy(p1);

console.log(p1 === p2); // false
```

使用 object.assign

```javascript
// 对象浅拷贝， 复制所有可枚举属性
const obj1 = { a: 1 };
const obj2 = { b: 2 };
// copy obj1 and obj2 to a new obj;
Object.assign({}, obj1, obj2);
```

使用扩展运算符进行浅 copy

```javascript
const obj1 = { a: 1, b: 2 };
// obj2 equal obj1
const obj2 = { ...obj1 };
```

在对象的拷贝方法中比较困扰的就是深层拷贝，此方法为深层拷贝；

```javascript
function deepCopy(data) {
  return JSON.parse(JSON.stringify(data));
}
```

## 事件总线（发布订阅模式）

```javascript
class EventEmitter {
  constructor() {
    this.cache = {};
  }

  on(name, fn) {
    if (this.cache[name]) {
      this.cache[name].push(fn);
    } else {
      this.cache[name] = [fn];
    }
  }

  off(name, fn) {
    let tasks = this.cache[name];
    if (tasks) {
      this.cache[name] = tasks.filter((f) => f === fn);
    }
  }

  emit(name, ...args) {
    if (this.cache[name]) {
      let tasks = [...this.cache[name]]; // 创建副本
      for (let fn of tasks) {
        fn(...args);
      }
    }
  }
}

const eventBus = new EventEmitter();

const f1 = function (name, age) {
  console.log(`f1 ${name} ${age}`);
};

const f2 = function (name, age) {
  console.log(`f2 ${name} ${age}`);
};

eventBus.on("a", f1);
eventBus.on("b", f2);

eventBus.emit("a", "tom", 22); // f1 tom 22
eventBus.emit("b", "cat", 18); // f2 cat 18
```

### 解析 URL 参数为对象

```javascript
function parseParam(url) {
  const reg = /.+\?(.+)$/;
  const arr = reg.exec(url)[1].split("&");
  const result = {};
  arr.forEach((item) => {
    let [k, v] = item.split("=");
    if (result.hasOwnProperty(k)) {
      result[k] = [...result[k], v];
    } else {
      result[k] = v;
    }
  });
  return result;
}

const url = "https://github.com/buuug7/your-resume?a=1&a=2&b=2&c=";
console.log(parseParam(url)); // { a: [ '1', '2' ], b: '2', c: '' }
```

## 字符串模板

```javascript
function render(template, data) {
  const reg = /\{\{(\w+)\}\}/;
  if (reg.test(template)) {
    const name = reg.exec(template)[1];
    template = template.replace(reg, data[name]);
    return render(template, data); // 递归调用
  }
  return template;
}

const template = "my name is {{name}} and age {{age}}.";
render(template, { name: "tom", age: 22 }); // my name is tom and age 22.
```

##

```javascript
const imgList = [...document.querySelectorAll("img")];
let length = imgList.length;

const imgLazyLoad = function () {
  console.log("img lazy load");
  let count = 0;
  let deletedIndex = [];
  imgList.forEach((item, index) => {
    let rect = item.getBoundingClientRect();
    if (rect.top < window.innerHeight) {
      item.src = item.dataset.src;
      deletedIndex.push(index);
      count++;
      // 图片全部加载完成后移除事件监听
      if (count === length) {
        document.removeEventListener("scroll", imgLazyLoad);
      }
    }
  });
};

document.addEventListener("scroll", imgLazyLoad);
```
