# vue 相关面试题

## Vue 双向绑定数据的原理

使用的是发布-订阅的模式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。

## Vue 中 key 的作用

key 是给每一个 VNODE 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速

## Vue 组件 data 为什么必须是函数

因为 js 本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有 Vue 实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了

## Vue 生命周期

从 Vue 实例创建、运行、到销毁的整个过程叫做 Vue 生命周期，在这个过程中会伴随着各种各样的事件发生，Vue 会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。

- 创建期间的生命周期函数：
  - beforeCreate：实例正在内存中被创建，此时，还没有初始化好 data 和 methods 属性
  - created：实例已经在内存中创建好了，此时 data 和 methods 已经创建完毕，此时还没有开始编译模板
  - beforeMount：此时已经完成了模板的编译并生成虚拟 DOM（vm.$el），但是还没有挂载到真实的 DOM 上
  - mounted：此时，已经将虚拟 DOM 挂载到真实 DOM 上了
- 运行期间的生命周期函数：
  - beforeUpdate：状态更新之前执行此函数，此时 data 中的状态值是最新的，但是界面上显示的数据是旧的，因为此时还没有开始运行渲染函数
  - updated：实例更新完毕之后调用此函数，此时 data 中的状态值和界面上显示的数据一致，界面已经被重新渲染好了
- 销毁期间的生命周期函数（当`vm.$destroy()`被调用的时候）：
  - beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。
  - destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

## $nextTick 是做什么的

$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM

## 什么是虚拟 DOM

虚拟 DOM (vdom)是真实 DOM 在内存中的表示,vdom 是虚拟 DOM（Virtual DOM）的简称，指的是用 JS 模拟的 DOM 结构，将 DOM 变化的对比放在 JS 层来做。换句话说，vdom 就是 JS 对象。然后根据这个对象构建出真实 DOM 树，插入到文档中。

虚拟 DOM 的优点：

- 减少 DOM 的操作，虚拟 dom 可以将多次操作合并为一次操作，减少 DOM 操作的次数

DOM diff：

DOM diff 是两个虚拟 DOM 树对比的算法：diff 算法仅在两个树的同级的虚拟节点之间做比较，递归地进行比较，最终实现整个 DOM 树的更新。diff 算法的三个步骤：

- 用 JS 对象的方式来表示 DOM 树的结构，然后根据这个对象构建出真实的 DOM 树，插到文档中
- 当状态变化的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树的差异
- 最后把所记录的差异应用到所构建的真正的 DOM 树上，这样就完成了一次视图更新

## diff 算法

diff 算法是进行虚拟节点元素的对比，并返回一个 patchs 对象，用来存储两个节点不同的地方，最后用 patchs 记录的消息去局部更新 Dom。

两个树如果完全比较的话需要时间复杂度为 O(n^3)，如果对 O(n^3)不太清楚的话建议去网上搜索资料。而在 Diff 算法中因为考虑效率的问题，只会对同层级元素比较，时间复杂度则为 O(n)，说白了就是深度遍历，并比较同层级的节点。

```javascript
// 判断两棵Virtual Dom Tree 差异
// 把差异更新到真实Dom中去
let patchs = diff(oldTree, newTree); //获取两棵Virtual Dom Tree 差异
patch(ulDom, patchs); //找到对应的真实dom，进行部分渲染
```
