# o(1), o(n), o(logn), o(nlogn)

描述算法复杂度时,常用 o(1), o(n), o(logn), o(nlogn)表示对应算法的时间复杂度，是算法的时空复杂度的表示。不仅仅用于表示时间复杂度，也用于表示空间复杂度。

O 后面的括号中有一个函数，指明某个算法的耗时/耗空间与数据增长量之间的关系。其中的 n 代表输入数据的量。

比如时间复杂度为 O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。再比如时间复杂度 O(n^2)，就代表数据量增大 n 倍时，耗时增大 n 的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的 O(n^2)的算法，对 n 个数排序，需要扫描 n×n 次。

再比如 O(logn)，当数据增大 n 倍时，耗时增大 logn 倍（这里的 log 是以 2 为底的，比如，当数据增大 256 倍时，耗时只增大 8 倍，是比线性还要低的时间复杂度）。二分查找就是 O(logn)的算法，每找一次排除一半的可能，256 个数据中查找只要找 8 次就可以找到目标。

O(nlogn)同理，就是 n 乘以 logn，当数据增大 256 倍时，耗时增大 256\*8=2048 倍。这个复杂度高于线性低于平方。归并排序就是 O(nlogn)的时间复杂度。

O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的 O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）
