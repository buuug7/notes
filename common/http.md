# http

HTTP 本身是一个无状态的连接协议, 为了支持客户端与服务器之间的交互, 我们就需要通过不同的技术为交互存储状态, 而这些不同的技术就是 Cookie 和 Session 了.

## HTTP 协议是无状态协议

无状态是指协议对于事务处理没有记忆能力. 缺少状态意味着如果后续处理需要前面的信息, 则它必须重传, 这样可能导致每次连接传送的数据量增大. 另一方面, 在服务器不需要先前信息时它的应答就较快.

客户端与服务器进行动态交互的 Web 应用程序出现之后, HTTP 无状态的特性严重阻碍了这些应用程序的实现, 毕竟交互是需要承前启后的, 简单的购物车程序也要知道用户到底在之前选择了什么商品. 于是, 两种用于保持 HTTP 连接状态的技术就应运而生了, 一个是 Cookie, 而另一个则是 Session. HTTP 本身是一个无状态的连接协议, 为了支持客户端与服务器之间的交互, 我们就需要通过不同的技术为交互存储状态, 而这些不同的技术就是 Cookie 和 Session 了.

## Cookie 是通过客户端保持状态的解决方案.

从定义上来说, Cookie 就是由服务器发给客户端的特殊信息, 而这些信息以文本文件的方式存放在客户端, 然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息. 让我们说得更具体一些: 当用户使用浏览器访问一个支持 Cookie 的网站的时候, 用户会提供包括用户名在内的个人信息并且提交至服务器; 接着, 服务器在向客户端回传相应的超文本的同时也会发回这些个人信息, 当然这些信息并不是存放在 HTTP 响应体(Response Body)中的, 而是存放于 HTTP 响应头(Response Header); 当客户端浏览器接收到来自服务器的响应之后, 浏览器会将这些信息存放在一个统一的位置, 对于 Windows 操作系统而言, 我们可以从: [系统盘]:\Documents and Settings\[用户名]\Cookies 目录中找到存储的 Cookie; 自此, 客户端再向服务器发送请求的时候, 都会把相应的 Cookie 再次发回至服务器. 而这次, Cookie 信息则存放在 HTTP 请求头(Request Header)了.

有了 Cookie 这样的技术实现, 服务器在接收到来自客户端浏览器的请求之后, 就能够通过分析存放于请求头的 Cookie 得到客户端特有的信息, 从而动态生成与该客户端相对应的内容. 通常, 我们可以从很多网站的登录界面中看到"请记住我"这样的选项, 如果你勾选了它之后再登录, 那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了, 而这个功能就是通过 Cookie 实现的.

## 与 Cookie 相对的一个解决方案是 Session, 它是通过服务器来保持状态的.

由于 Session 这个词汇包含的语义很多, 因此需要在这里明确一下 Session 的含义. 首先, 我们通常都会把 Session 翻译成会话, 因此我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session. 从这个语义出发, 我们会提到 Session 持续的时间, 会提到在 Session 过程中进行了什么操作等等; 其次, Session 指的是服务器端为客户端所开辟的存储空间, 在其中保存的信息就是用于保持状态. 从这个语义出发, 我们则会提到往 Session 中存放什么内容, 如何根据键值从 Session 中获取匹配的内容等.

要使用 Session, 第一步当然是创建 Session 了. 那么 Session 在何时创建呢? 当然还是在服务器端程序运行的过程中创建的, 不同语言实现的应用程序有不同创建 Session 的方法. 在创建了 Session 的同时, 服务器会为该 Session 生成唯一的 Session ID, 而这个 Session ID 在随后的请求中会被用来重新获得已经创建的 Session; 在 Session 被创建之后, 就可以调用 Session 相关的方法往 Session 中增加内容了, 而这些内容只会保存在服务器中, 发到客户端的只有 Session ID; 当客户端再次发送请求的时候, 会将这个 Session ID 带上, 服务器接受到请求之后就会依据 Session ID 找到相应的 Session, 从而再次使用. 正是这样一个过程, 用户的状态也就得以保持了.

## session 和 cookie 区别

session 和 cookie 的最大区别在于 session 是保存在服务端的内存里面, 而 cookie 保存于浏览器或客户端文件里面; session 是基于访问的进程, 记录了一个访问的开始到结束, 当浏览器或进程关闭之后, session 也就"消失"了, 而 cookie 更多地被用于标识用户, 它可以是长久的, 用于用户跟踪和识别唯一用户(Unique Visitor).

## 关于 cookie

cookie 是一小段文本信息, 伴随着用户请求和页面在 Web 服务器和浏览器之间传递. 用户每次访问站点时, Web 应用程序都可以读取 cookie 包含的信息.

session 的实现机制里面已经介绍了常见的方法是使用会话 cookie(session cookie)的方式, 而平常所说的 cookie 主要指的是另一类 cookie——持久 cookie(persistent cookies). 持久 cookie 是指存放于客户端硬盘中的 cookie 信息(设置了一定的有效期限), 当用户访问某网站时, 浏览器就会在本地硬盘上查找与该网站相关联的 cookie. 如果该 cookie 存在, 浏览器就将它与页面请求一起通过 HTTP 报头信息发送到您的站点, 然后在系统会比对 cookie 中各属性和值是否与存放在服务器端的信息一致, 并根据比对结果确定用户为"初访者"或者"老客户".

持久 cookie 一般会保存用户的用户 ID, 该信息在用户注册或第一次登录的时候由服务器生成包含域名及相关信息的 cookie 发送并存放到客户端的硬盘文件上, 并设置 cookie 的过期时间, 以便于实现用户的自动登录和网站内容自定义.

## 关于 session

session 被用于表示一个持续的连接状态, 在网站访问中一般指代客户端浏览器的进程从开启到结束的过程. session 其实就是网站分析的访问(visits)度量, 表示一个访问的过程.

session 的常见实现形式是会话 cookie(session cookie), 即未设置过期时间的 cookie, 这个 cookie 的默认生命周期为浏览器会话期间, 只要关闭浏览器窗口, cookie 就消失了. 实现机制是当用户发起一个请求的时候, 服务器会检查该请求中是否包含 sessionid, 如果未包含, 则系统会创造一个名为 JSESSIONID 的输出 cookie 返回给浏览器(只放入内存, 并不存在硬盘中), 并将其以 HashTable 的形式写到服务器的内存里面; 当已经包含 sessionid, 服务端会检查找到与该 session 相匹配的信息, 如果存在则直接使用该 sessionid, 若不存在则重新生成新的 session. 这里需要注意的是 session 始终是有服务端创建的, 并非浏览器自己生成的.

但是浏览器的 cookie 被禁止后 session 就需要用 get 方法的 URL 重写的机制或使用 POST 方法提交隐藏表单的形式来实现.

这里有一个很关键性的注意点, 即 session 失效时间的设置, 这里要分两方面来看: 浏览器端和服务端. 对于浏览器端而言, session 与访问进程直接相关, 当浏览器被关闭时, session 也随之消失; 而服务器端的 session 失效时间一般是人为设置的, 目的是能定期地释放内存空间, 减小服务器压力, 一般的设置为当会话处于非活动状态达 20 或 30 分钟时清除该 session, 所以浏览器端和服务端的 session 并非同时消失的, session 的中断也并不一定意味着用户一定离开了该网站. 目前 Google Analytics 和 Omniture 都定义当间隔 30 分钟没有动作时, 算作一次访问结束.

还有一点需要注意, 就是现在的浏览器好像趋向于多进程的 session 共享, 即通过多个标签或页面打开多个进程访问同一网站时共享一个 session cookie, 只有当浏览器被关闭时才会被清除, 也就是你有可能在标签中关闭了该网站, 但只要浏览器未被关闭并且在服务器端的 session 未失效前重新开启该网站, 那么就还是使用原 session 进行浏览; 而某些浏览器在打开多页面时也可能建立独立的 session, IE8, Chrome 默认都是共享 session 的, 在 IE8 中可以通过菜单栏中的文件->新建会话来建立独立 session 的浏览页面.

## HTTP Referer

简而言之, HTTP Referer 是 header 的一部分, 当浏览器向 web 服务器发送请求的时候, 一般会带上 Referer, 告诉服务器我是从哪个页面链接过来的, 服务器籍此可以获得一些信息用于处理. 比如从我主页上链接到一个朋友那里, 他的服务器就能够从 HTTP Referer 中统计出每天有多少用户点击我主页上的链接访问他的网站.

Referer 的正确英语拼法是 referrer. 由于早期 HTTP 规范的拼写错误, 为了保持向后兼容就将错就错了. 其它网络技术的规范企图修正此问题, 使用正确拼法, 所以目前拼法不统一.
